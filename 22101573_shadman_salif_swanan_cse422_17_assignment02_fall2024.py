# -*- coding: utf-8 -*-
"""22101573_Shadman Salif Swanan_CSE422_17_Assignment02_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZcodBJ7aT40ZlVQA1TcXT-UsWimsweXW

# PART **1**
"""

import random
N, T = map(int, input().split())
course_codes = [input().strip() for _ in range(N)]
if T < N:
    print("Invalid input")
    exit()

def fitness_function(chromosome, N, T):
    overlap_penalty = 0
    consistency_penalty = 0

    for t in range(T):
        timeslot = chromosome[t * N:(t + 1) * N]
        overlap_penalty += max(0, timeslot.count('1') - 1)

    for c in range(N):
      course_count = 0
      for t in range(T):
        index = t * N + c
        if chromosome[index] == '1':
          course_count += 1

    total_penalty = -(overlap_penalty + consistency_penalty)
    return total_penalty

def generate_population(size, N, T):
    population = []

    for i in range(size):
        chromosome = ['0'] * (N * T)

        for j in range(N):
            timeslot = int((T * j) % T)
            chromosome[timeslot * N + j] = '1'

        chromosome_str = ""

        for k in range(len(chromosome)):
            chromosome_str += chromosome[k]

        population.append(chromosome_str)

    return population


def select_parents(population, N, T):
    fitness_values = []
    for chromosome in population:
        fitness = fitness_function(chromosome, N, T)
        fitness_values.append(fitness)

    min_fitness = min(fitness_values)

    adjusted_fitness_values = []
    for fitness in fitness_values:
        adjusted_fitness = fitness - min_fitness + 1
        adjusted_fitness_values.append(adjusted_fitness)

    parents = random.choices(population, weights=adjusted_fitness_values, k=2)
    return parents


def single_point_crossover(parent1, parent2):
    point = random.randint(1, len(parent1) - 1)
    offspring1 = parent1[:point] + parent2[point:]
    offspring2 = parent2[:point] + parent1[point:]

    return offspring1, offspring2

def mutate(chromosome,m_rate=0.1):
    mutated = list(chromosome)
    for i in range(len(mutated)):
        if random.random() < m_rate:
          if mutated[i] == '0':
            mutated[i] = '1'
          else:
            mutated[i] = '0'

    mutated_chromosome = ""
    for gene in mutated:
        mutated_chromosome += gene
    return mutated_chromosome

def genetic_algorithm(N, T, course_codes, max_generations=1000, population_size=20):
    population = generate_population(population_size, N, T)
    best_solution = None
    best_fitness = float('-inf')

    for generation in range(max_generations):
        fitness_scores = [(chromosome, fitness_function(chromosome, N, T)) for chromosome in population]
        fitness_scores.sort(key=lambda x: x[1], reverse=True)

        if fitness_scores[0][1] > best_fitness:
            best_solution, best_fitness = fitness_scores[0]

        if best_fitness == 0:
            break

        new_population = []
        while len(new_population) < population_size:
            parent1, parent2 = select_parents(population, N, T)
            offspring1, offspring2 = single_point_crossover(parent1, parent2)
            new_population.extend([mutate(offspring1), mutate(offspring2)])

        population = new_population[:population_size]

    return best_solution, best_fitness


solution, fitness = genetic_algorithm(N, T, course_codes)
print(solution)
print(fitness)

"""# **PART 2**"""

import random

def two_point_crossover(parent1, parent2):
    length = len(parent1)
    point1 = random.randint(1, length - 2)
    point2 = random.randint(point1 + 1, length - 1)
    offspring1 = parent1[:point1] + parent2[point1:point2] + parent1[point2:]
    offspring2 = parent2[:point1] + parent1[point1:point2] + parent2[point2:]
    return offspring1, offspring2

parent1 = input().strip()
parent2 = input().strip()

offspring1, offspring2 = two_point_crossover(parent1, parent2)

print(offspring1)
print(offspring2)